\documentclass[10pt,letterpaper]{report}
\usepackage[latin1]{inputenc}

\usepackage{avant}
\renewcommand*\familydefault{\sfdefault}

\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.85}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\usepackage{hyperref}
\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  sensitive=true
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

\begin{document}
\title{golang notes}
\maketitle
\tableofcontents
\chapter{Getting Started}
\section{Go Tools}
Go is a \textbf{compiled programming language}, which means source code (the code you write) is translated into a language that your computer can understand.\\
To find out the go version which is running:
\begin{lstlisting}
luca@scippane:~$ go version
go version go1.3.1 linux/amd64
\end{lstlisting}
The \textbf{Go tool suite} is made up of several different commands and sub-commands. A list of those commands is available by typing:
\begin{lstlisting}
luca@scippane:~$ go help
\end{lstlisting}
To run a program, given a file with the code called \textit{main.go}, then use the command:
\begin{lstlisting}
go run main.go
\end{lstlisting}
from the folder where main.go is saved.\\
The \textit{go run} command takes the subsequent files (separated by spaces), compiles them into an executable saved in a temporary directory and then runs the program.
\section{A Go Program}
\subsection{Package Declaration}
\begin{lstlisting}
package main
\end{lstlisting}
This is know as a \textbf{package declaration}. Every Go program \textbf{must start with a package declaration}. Packages are Go's way of organizing and reusing code.\\
There are two types of Go programs: \textbf{executables} and \textbf{libraries}. Executable applications are the kinds of programs that we can run directly from the terminal. Libraries are collections of code that we package together so that we can use them in other programs.\\
\subsection{Import}
\begin{lstlisting}
import "fmt"
\end{lstlisting}
The \textbf{import} keyword is how we \textbf{include code from other packages} to use with our program. The \textit{fmt} package (shorthand for format) implements formatting for input and output.\\
\subsection{Comments}
Go supports two different styles of comments:
\begin{itemize}
 \item \textit{//} comments in which all the text between the // and the end of the line is part of the comment
 \item \textit{/* */} comments where everything between the * s is part of the comment. (And may include multiple lines).
 \end{itemize}
 \subsection{Function Declaration}
 \begin{lstlisting}
 func main() {
fmt.Println("Hello World")
}
\end{lstlisting}
All functions start with the \textbf{keyword \textit{func}} followed by the \textbf{name of the function} ( \textit{main} in this case), a list of zero or more \textbf{parameters} surrounded by parentheses, an optional \textbf{return type} and a \textbf{body} which is surrounded by curly braces.\\
The name \textit{main} is special because it's the function that gets called when you execute the program.\\
\subsection{Documentation}
You can find out more about a function by using the command \textit{godoc}; for example:
\begin{lstlisting}
godoc fmt Println
\end{lstlisting}
\chapter{Types}
Go is a \textbf{statically typed programming language}. This means that variables always have a specific type and that type cannot change.
\section{Numbers}
Go has several different types to represent numbers. Generally we split numbers into two different kinds: \textbf{integers} and \textbf{floating-point} numbers.
\subsection{Integers}
Integers are numbers without a decimal component.\\
Go's integer types are: \textit{uint8 , uint16 , uint32 , uint64 , int8 , int16 , int32 and int64}. 8, 16, 32 and 64 tell us how many bits each of the types use.\\
\textit{uint} means unsigned integer while \textit{int} means signed integer.\\
There are also \textbf{3 machine dependent integer types}: \textit{uint , int and uintptr}. They are machine dependent because their size depends on the type of architecture you are using.\\
\textbf{Generally if you are working with integers you should just use the \textit{int} type.}
\subsection{Floating Point}
Floating point numbers are numbers that contain a decimal component.
Go has \textbf{two floating point types}: \textit{float32} and \textit{float64}. \\
As well as \textbf{two additional types for representing complex numbers}: \textit{complex64} and \textit{complex128}.\\
Generally \textbf{we should stick with float64 when working with floating point numbers}.
\section{Strings}
A string is a sequence of characters with a definite length used to represent text.\\
String literals can be created using \textbf{double quotes} "Hello World" or \textbf{back ticks} `Hello World`. The difference between these is that double quoted strings can not contain newlines and they allow special escape sequences.\\
For example \textbackslash n gets replaced with a new line and \textbackslash t gets replaced with a tab character.\\
Several common operations on strings include:
\begin{itemize}
\item finding the length of a string: \textit{len("Hello World")}
\item accessing an individual character in the string: \textit{"Hello World"[1]}
\item and concatenating two strings together: \textit{"Hello " + "World"}
\end{itemize} 
Things to notice
\begin{itemize}
\item A space is also considered a character
\item Strings are indexed starting at 0 not 1
\item The function which returns a character in a position returns an int not a string
\item Concatenation uses the same symbol as addition
\end{itemize}
\section{Boolean}
A boolean value is a special 1 bit integer type used to represent true and false.\\
Three logical operators are used with boolean values:
\begin{itemize}
\item \&\& AND
\item || OR
\item ! NOT
\end{itemize}
\chapter{Variables}
A variable is a storage location, with a specific type and an associated name.\\
Variables in Go are created by first using the \textbf{\textit{var} keyword}, then specifying the \textbf{variable name} (e.g. x ), the \textbf{type} (e.g. string )and finally assigning a \textbf{value} to the variable (e.g. "Hello World" ). The last step is optional.
\begin{lstlisting}
var x string = "Hello World"
\end{lstlisting}
To declare a variable Go also supports a shorter statement:
\begin{lstlisting}
x := "Hello World"
x := 5
\end{lstlisting}

In this shorter statement the type and the keyword \textit{var} can be omitted.
\section{Equality}
The symbol for equalityis \textit{==} .\\
== is an operator like + and it returns a boolean.
\section{Scope}
\textbf{Go is lexically scoped using blocks}.\\
Basically this means that the variable exists within the nearest curly braces { } (a block) including any nested curly braces (blocks), but not outside of them.\\
Example 1 - This is ok
\begin{lstlisting}
var x string = "Hello World"
func main() {
	fmt.Println(x)
}
func f() {
	fmt.Println(x)
}
\end{lstlisting}
Example 2 - This is NOT ok (variable x is undefined for func f)
\begin{lstlisting}
func main() {
	var x string = "Hello World"
	fmt.Println(x)
}
func f() {
	fmt.Println(x)
}
\end{lstlisting}
\section{Constants}
Go also has support for \textbf{constants}. Constants are basically variables whose values cannot be changed later. They are created in the same way you create variables but instead of using the \textit{var} keyword we use the \textit{const} keyword.
\section{Defining Multiple Variables}
Go also has another shorthand when you need to define multiple variables. Use the keyword \textit{var} (or \textit{const} ) followed by parentheses with each variable on its own line.
\begin{lstlisting}
var (
	a = 5
	b = 10
	c = 15
)
\end{lstlisting}
\chapter{Control Structures}
\section{for}
The \textit{for} statement allows us to repeat a list of statements (a block) multiple times.\\
Other programming languages have a lot of different types of loops (while, do, until, foreach, ...) but Go only has one that can be used in a variety of different ways.\\
Syntax
\begin{lstlisting}
for i := 1; i <= 10; i++ {
	fmt.Println(i)
}
\end{lstlisting}
\section{if}
It looks like the compiler really requires else to be after the \} like below and the curly brackets are mandatory.
\begin{lstlisting}
if i % 2 == 0 {
// even
} else {
// odd
}
\end{lstlisting}
If statements also have an \textbf{optional \textit{else} part}. If the condition evaluates to true then the block after the condition is run, otherwise either the block is skipped or if the else block is present that block is run.\\
If statements can also have \textbf{\textit{else if} parts}:
\begin{lstlisting}
if i % 2 == 0 {
	// divisible by 2
} else if i % 3 == 0 {
	// divisible by 3
} else if i% 4 == 0 {
	// divisible by 4
}
\end{lstlisting}
The conditions are checked top down and \textbf{the first one to result in true will have its associated block executed}. None of the other blocks will execute, even if their conditions also pass. (So for example the number 8 is divisible by both 4 and 2, but the // divisible by 4 block will never execute because the // divisible by 2 block is done first).
\section{switch}
A \textit{switch} statement starts with the keyword \textit{switch} followed by an \textbf{expression} and then a series of \textit{case}(s).\\
The value of the expression is compared to the expression following each \textit{case} keyword. If they are equivalent then the statement(s) following the \textit{:} is executed.\\
Like an if statement each case is checked top down and \textbf{the first one to succeed is chosen}. A switch also supports \textbf{a default case} which will happen if none of the cases matches the value.
\begin{lstlisting}
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
default: fmt.Println("Unknown Number")
}
\end{lstlisting}
\chapter{Arrays, Slices and Maps}
\section{Arrays}
An array is a numbered sequence of elements of a single type with a fixed length. In Go they look like this:
\begin{lstlisting}
var x [5]int
\end{lstlisting}
Like strings, arrays are indexed starting from 0.\\
Note how it is possible to print all elements in an array:
\begin{lstlisting}
package main
import "fmt"
func main() {
	var x [5]int
	x[4] = 100
	fmt.Println(x) //Print all elements
}
\end{lstlisting}
The result is:
\begin{lstlisting}
[0 0 0 0 100]
\end{lstlisting}
Consider this simple program:
\begin{lstlisting}
func main() {
	var x [5]float64
	x[0] = 98
	x[1] = 93
	x[2] = 77
	x[3] = 82
	x[4] = 83
	var total float64 = 0
	for _, value := range x {
		total += value
	}
	fmt.Println(total / float64(len(x)))
}	
\end{lstlisting}
There are few things to note:
\begin{itemize}
\item \textit{float64(len(x))} is an example of \textbf{type conversion}. In general to convert between types you use the type name like a function.
\item \textit{for \_, value := range x} is another way of using the for loop. \textit{value} is the same as \textit{x[i]} . We use the keyword \textit{range} followed by the name of the variable we want to loop over
\item A single \_ (underscore) is used to tell the compiler that \textbf{we don't need this}. (In this case we don't need the iterator variable)
\end{itemize}
Go also provides \textbf{a shorter syntax for creating arrays}:
\begin{lstlisting}
x := [5]float64{ 98, 93, 77, 82, 83 }
\end{lstlisting}
Go allows you to break it up like this:
\begin{lstlisting}
x := [5]float64{
	98,
	93,
	77,
	82,
	83,
}
\end{lstlisting}
Notice the extra trailing , after 83 .\\
If we want to remove an element from the array we can do something like this:
\begin{lstlisting}
x := [4]float64{
	98,
	93,
	77,
	82,
	// 83,
}
\end{lstlisting}
This example illustrates \textbf{a major issue with arrays}: their \textbf{length is fixed} and \textbf{part of the array's type name}. In order to remove the last item, we actually had to \textbf{change the type as well}. Go's solution to this problem is to use a different type: \textbf{slices}.
\subsection{Creating Arrays}
Arrays are created using the syntaxes:
\begin{lstlisting}
[length]Type
[N]Type{value1, value2, ... , valueN}
[ ... ]Type{value1, value2, ... , valueN}
\end{lstlisting}
If the \textit{...} (ellipsis) operator is used in this context, Go will \textbf{calculate the array's length for us}. In all cases an \textbf{array's length is fixed and unchangeable}.\\
Go guarantees that \textbf{all array items are initialized to their zero value} if they are not explicitly initialized or are only partly initialized when they are created. Example:
\begin{lstlisting}
grid1[1][0], grid1[1][1], grid1[1][2] = 8, 6, 2
fmt.Printf("%-8T %2d %v\n", grid1, len(grid1), grid1)
\end{lstlisting}
would result in:
\begin{lstlisting}
[[0 0 0] [8 6 2] [0 0 0]]
\end{lstlisting}
The length of an array is given by the \textit{len()} function.\\
Arrays can be iterated using a \textit{for ... range} loop
\subsection{Comments About Arrays}
In general, \textbf{Go's slices are more flexible, powerful, and convenient than arrays}.\\
\begin{itemize}
\item Arrays are passed by value (i.e., copied), whereas slices are cheap to pass, regardless of their length or capacity, since they are references.
\item Arrays are of fixed size whereas slices can be resized.
\end{itemize}
\textbf{It is recommended to slices} unless there is a very specific need to use an array in a particular case.\\
Both arrays and slices can be sliced using the syntaxes shown in 
Section ~\ref{subsec:sliceops}
\section{Slices}
\textbf{A slice is a segment of an array}. Like arrays slices are indexable and have a length. Unlike arrays \textbf{this length is allowed to change}. Here's an example of a slice:
\begin{lstlisting}
var x []float64
\end{lstlisting}
A Go slice is a \textbf{variable-length fixed-capacity sequence of items of the same type}. Despite their fixed capacity, slices can be shrunk by slicing them and can be grown using the efficient built-in \textit{append()} function.\\
\textbf{Multidimensional slices} can be created quite naturally by using items that are themselves slices and the lengths of the inner slices in multidimensional slices may vary.\\
Although arrays and slices store items of the same type there is no limitation in practice. This is because the type used could be an interface. So we could store items of any types provided that they all met the specified interface.\\
\subsection{Creating Slices}
Slices are created using the syntaxes:
\begin{lstlisting}
make([]Type, length, capacity)
make([]Type, length)
[]Type{}
[]Type{value1, value2, ... , valueN}
\end{lstlisting}
The built-in \textit{make()} function is used to create slices, maps, and channels. When used to create a slice it creates a \textbf{hidden zero-value initialized array and returns a slice reference} that refers to the hidden array.\\
The hidden array, like all arrays in Go, is of fixed length, with the length being the slice's \textbf{capacity} if the first syntax is used, or the slice's length if the second syntax is used, or the number of items in braces if the composite literal (third and fourth) syntax is used.\\
The composite literal (fourth) syntax is very convenient, since it allows us to create a slice with some \textbf{initial values}. The syntax \textit{[]Type{}} is equivalent to \textit{make([]Type, 0)} ; both create an \textbf{empty slice}. This isn't useless since we can use the built-in \textit{append()} function to effectively increase a slice's capacity.\\
Valid index positions for a slice range from 0 to \textit{len(slice)-1} . A slice can be resliced to reduce its length, and if a slice's capacity is greater than its length the slice can be resliced to increase its length up to its capacity. We can also increase a slice's capacity using the built-in \textit{append()} function.\\
\subsection{Examples}
If you want to create a slice you should use the built-in \textit{make} function:
\begin{lstlisting}
x := make([]float64, 5)
\end{lstlisting}
This creates a slice that is associated with an underlying \textit{float64} array of length 5.\\
The make function also allows a \textbf{3rd parameter}:
\begin{lstlisting}
x := make([]float64, 5, 10)
\end{lstlisting}
10 represents the \textbf{capacity} of the underlying array which the slice points to.\\
\textbf{Another way} to create slices is to use the \textit{[low : high]} expression:
\begin{lstlisting}
arr := []float64{1,2,3,4,5}
x := arr[0:5]
\end{lstlisting}
\textit{low} is the index of where to start the slice and \textit{high} is the index where to end it (but \textbf{not including the index itself}). For example while arr[0:5] returns [1,2,3,4,5] , arr[1:4] returns [2,3,4].\\
For convenience we are also allowed to \textbf{omit low , high or even both low and high} . arr[0:] is the same as arr[0:len(arr)] , arr[:5] is the same as arr[0:5] and arr[:] is the same as arr[0:len(arr)] .\\
\subsection{Slices and Their Hidden Arrays}
In this example:
\begin{lstlisting}
s := []string{"A", "B", "C", "D", "E", "F", "G"}
t := s[:5]
// [A B C D E]
u := s[3 : len(s)-1] // [D E F]
fmt.Println(s, t, u)
u[1] = "x"
fmt.Println(s, t, u)
\end{lstlisting}
The result is:
\begin{lstlisting}
[A B C D E F G] [A B C D E] [D E F]
[A B C D x F G] [A B C D x] [D x F]
\end{lstlisting}
Since the slices s , t , and u all refer to the same underlying data, a change to one will affect any of the others that refer to the same data. 
\subsection{Slices Functions}
Go includes two built-in functions to assist with slices: \textit{append} and \textit{copy}.\\
Here is an example of \textit{append} :
\begin{lstlisting}
func main() {
	slice1 := []int{1,2,3}
	slice2 := append(slice1, 4, 5)
	fmt.Println(slice1, slice2)
}
\end{lstlisting}
After running this program \textit{slice1} has \textit{[1,2,3]} and \textit{slice2} has \textit{[1,2,3,4,5]}.\\
\textit{append} creates a new slice by taking an existing slice (the first argument) and appending all the following arguments to it.\\
Example of \textit{copy}:
\begin{lstlisting}
func main() {
	slice1 := []int{1,2,3}
	slice2 := make([]int, 2)
	copy(slice2, slice1)
	fmt.Println(slice1, slice2)
}
\end{lstlisting}
After running this program slice1 has [1,2,3] and slice2 has [1,2]\\
The contents of slice1 are copied into slice2 , but since slice2 has room for only two elements only the first two elements of slice1 are copied.
\subsection{Slice Operations}
\label{subsec:sliceops}
\begin{tabular}{|l|p{10cm}|}
\hline
Syntax & Description\\ \hline
s[n] & The item at index position n in slice s\\ \hline
s[n:m] & A slice taken from slice s from index positions n to m-1\\ \hline
s[n:] & A slice taken from slice s from index positions n to len(s)-1\\ \hline
s[:m] & A slice taken from slice s from index positions 0 to m-1\\ \hline
s[:] & A slice taken from slice s from index positions 0 to len(s)-1\\ \hline
cap(s) & The capacity of slice s; always $\ge$ len(s)\\ \hline
len(s) & The number of items in slice s; always $\le$ cap(s)\\ \hline
s = s[:cap(s)] & Increase slice s's length to its capacity if they are different\\ \hline
\end{tabular}
\subsection{Indexing and Slicing Slices}
A slice is a reference to a hidden array and slices of slices are also references to the same hidden array. Here is an example to illustrate what this means.
\begin{lstlisting}
s := []string{"A", "B", "C", "D", "E", "F", "G"}
t := s[2:6]
fmt.Println(t, s, "=", s[:4], "+", s[4:])
s[3] = "x"
t[len(t)-1] = "y"
fmt.Println(t, s, "=", s[:4], "+", s[4:])
\end{lstlisting}
Result:
\begin{lstlisting}
[C D E F] [A B C D E F G] = [A B C D] + [E F G]
[C x E y] [A B C x E y G] = [A B C x] + [E y G]
\end{lstlisting}
When we change the data, whether via the original \textit{s} slice or from the \textit{t} slice of the \textit{s} slice, the same underlying data is changed, so both slices are affected.
\subsection{Iterating Slices}
If we want to access the items \textbf{without modifying} them we can use a \textit{for ... range} loop; and if we need to \textbf{modify} items we can use a \textit{for} loop with a loop counter.
\begin{lstlisting}
amounts := []float64{237.81, 261.87, 273.93, 279.99, 281.07, 303.17,
231.47, 227.33, 209.23, 197.09}
sum := 0.0
for _, amount := range amounts {
sum += amount
}
fmt.Printf("Sum %.1f --> %.1f\n", amounts, sum)
\end{lstlisting}
Result:
\begin{lstlisting}
Sum [237.8 261.9 273.9 280.0 281.1 303.2 231.5 227.3 209.2 197.1] --> 2503.0
\end{lstlisting}
Note The \textit{for ...  range} loop assigns a 0-based loop counter, which in this case we have discarded using the blank identifier ( \_ ) and a \textbf{copy} of the corresponding item from the slice. This means that any changes that are applied to the item \textbf{affect only the copy}, not the item in the slice.\\
\textbf{If we want to modify} the items in the slice we must use a \textit{for} loop that just provides valid slice indexes and not copies of the slice's items.
\begin{lstlisting}
for i := range amounts {
amounts[i] *= 1.05
sum += amounts[i]
}
fmt.Printf("Sum %.1f --> %.1f\n", amounts, sum)
\end{lstlisting}
Result:
\begin{lstlisting}
Sum [249.7 275.0 287.6 294.0 295.1 318.3 243.0 238.7 219.7 206.9] --> 2628.1
\end{lstlisting}
Here we have increased each item in the slice by 5\% and accumulated their sum.
\subsection{Modifying Slices}
If we need to append to a slice we can use the built-in \textit{append()} function. \textbf{This function takes the slice to be appended to and one or more individual items to append}. If we want to append a slice to a slice we must use the \textit{...} (ellipsis) operator to tell Go to pass the slice to be added as individual values. The values to append \textbf{must be of the same type as the slice's value type}. In the case of a string we can append its individual bytes to a byte slice by using the ellipsis syntax.
\begin{lstlisting}
s := []string{"A", "B", "C", "D", "E", "F", "G"}
t := []string{"K", "L", "M", "N"}
u := []string{"m", "n", "o","p", "q", "r"}
s = append(s, "h", "i", "j") //Append individual values
s = append(s, t...)			//Append all of a slice values
s = append(s, u[2:5]...)		//Append a sub-slice
b := []byte{'U', 'V'}
letters := "wxy"
b = append(b, letters...)	//Append a string's bytes to a byte slice
fmt.Printf("%v\n%s\n", s, b)
\end{lstlisting}
Result:
\begin{lstlisting}
[A B C D E F G h i j K L M N o p q]
UVwxy
\end{lstlisting}
The built-in \textit{append()} function takes a slice and one or more values and returns a (possibly new) slice which has the original slice's contents, plus the given value or values as its last item or items. If the original slice's capacity is sufficient for the new items \textit{append()} puts the new value or values in the empty position or positions at the end and returns the original slice with its length increased by the number of items added. If the original slice doesn't have sufficient capacity, the \textit{append()} function creates a new slice under the hood and copies the original slice's items into it, plus the new value or values at the end, and returns the new slice.
\subsection{Sorting Slices}
The standard library's \textit{sort} package provides functions for sorting slices of \textit{int}, \textit{float64}, and \textit{string}, for checking if such a slice is sorted, and for searching for an item in a sorted slice using the fast binary search algorithm.\\
There are also generic \textit{sort.Sort()} and \textit{sort.Search()} functions that can easily be used with custom data.\\
\\
\begin{tabular}{|l|p{8cm}|}
\hline
Syntax & Description\\ \hline
sort.Float64s(fs) & Sorts fs of type []float64 into ascending order\\ \hline
sort.Float64sAreSorted(fs) & Returns true if fs of type []float64 is sorted\\ \hline
sort.Ints(is) & Sorts is of type []int into ascending order\\ \hline
sort.IntsAreSorted(is) & Returns true if is of type []int is sorted\\ \hline
sort.IsSorted(d) & Returns true if d of type sort.Interface is sorted\\ \hline
sort.Search(size, fn) & Returns the index position in a sorted slice in scope of length size where function fn with the signature func(int) bool returns true (see text)\\ \hline
sort.SearchFloat64s(fs, f) & Returns the index position of f of type float64 in sorted fs of type []float64\\ \hline
sort.SearchInts(is, i) & Returns the index position of i of type int in sorted is of type []int\\ \hline
sort.SearchStrings(ss, s) & Returns the index position of s of type string in sorted ss of type []string\\ \hline
sort.Sort(d) & Sorts d of type sort.Interface (see text)\\ \hline
sort.Strings(ss) & Sorts ss of type []string into ascending order\\ \hline
sort.StringsAreSorted(ss) & Returns true if ss of type []string is sorted\\ \hline
\end{tabular}
\\

The standard library's \textit{sort.Strings()} function takes a \textit{[]string} and sorts the strings in-place in ascending order in terms of their underlying bytes.\\
The \textit{sort.Sort()} function can sort items of any type that provide the methods in the \textit{sort.Interface} , that is, items of a type that provide the \textit{Len()} , \textit{Less()} , and \textit{Swap()} methods, each with the required signatures.\\
Example:
\begin{lstlisting}
files := []string{"Test.conf", "util.go", "Makefile", "misc.go", "main.go"}
fmt.Printf("Unsorted:%q\n", files)
sort.Strings(files) // Standard library sort function
fmt.Printf("Underlying bytes: %q\n", files)
\end{lstlisting}
Result:
\begin{lstlisting}
Unsorted:["Test.conf" "util.go" "Makefile" "misc.go" "main.go"]
Underlying bytes: ["Makefile" "Test.conf" "main.go" "misc.go" "util.go"]
\end{lstlisting}
\subsection{Searching Slices}
Go provides a \textit{sort.Search()} method which uses the \textbf{binary search algorithm}. This requires the comparison of only $log_{2}(n)$ items (where n is the number of items) each time.
\begin{lstlisting}
files := []string{"Test.conf", "util.go", "Makefile", "misc.go", "main.go"}
sort.Strings(files)
fmt.Printf("%q\n", files)
i := sort.Search(len(files),
	func(i int) bool { return files[i] >= target })
if i < len(files) && files[i] == target {
	fmt.Printf("found \"%s\" at files[%d]\n", files[i], i)
}
\end{lstlisting}
Result:
\begin{lstlisting}
["Makefile" "Test.conf" "main.go" "misc.go" "util.go"]
found "Makefile" at files[0]
\end{lstlisting}
The \textit{sort.Search()} function takes two arguments:
\begin{itemize}
\item the \textbf{length} of the slice to work
\item a \textbf{function} that compares an item in a \textbf{sorted slice} with a target item using the >= operator for slices that are sorted in ascending order or the <= operator for slices sorted in descending order. The function must be a closure, that is, it must be created in the scope of the slice it is to work on since it must capture the slice as part of its state.
\end{itemize}
\textbf{The \textit{sort.Search()} function returns an \textit{int}} ; only if this is less than the length of the slice and the item at that index position matches the target, can we be sure that we have found the item we are looking for.
\section{Maps}
Although slices can account for most data structure use cases, in some situations we need to be able to store key-value pairs with fast lookup by key. This functionality is provided by Go's \textbf{map type}. A map is \textbf{an unordered collection of key-value pairs}.\\
Also known as an associative array, a hash table or a dictionary, maps are used to look up a value by its associated key.\\
A map's keys must all be of the same type, and so must its values-although the key and value types can (and often do) differ.\\
A Go map is an unordered collection of key-value pairs whose capacity is limited only by machine memory.\\
\textbf{Keys are unique and may only be of a type that sensibly supports the == and != operators}; so most of the built-in types can be used as keys (e.g., \textit{int} , \textit{float64} , \textit{rune} , \textit{string} , comparable arrays and struct s, and custom types based on these, as well as pointers).\\
With respect to a map's values, just as with the items in a slice, \textbf{there is no limitation in practice}. This is because the value type used could be an interface. So we could store values of any types provided that they all met the specified interface (i.e., had the method or methods that the interface requires).
\subsection{Maps Operations}
Go's map operations are listed below:\\
\begin{tabular}{|l|p{10cm}|}
\hline
Syntax & Description\\ \hline
m[k] = v & Assigns value \textit{v} to map \textit{m} under key \textit{k} ; if \textit{k} is already in the map its previous value is discarded\\ \hline
delete(m, k) & Deletes key \textit{k} and its associated value from map \textit{m} , or safely does nothing\\ \hline
v := m[k] & Retrieves the value that corresponds to map \textit{m} 's key \textit{k} and assigns it to \textit{v} ; or assigns the zero value for the value's type to \textit{v} , if \textit{k} isn't in the map\\ \hline
v, found := m[k] & Retrieves the value that corresponds to map \textit{m} 's key \textit{k} and assigns it to \textit{v} and true to found ; or assigns the zero value for the value's type to \textit{v} and false to found , if \textit{k} isn't in the map\\ \hline
len(m) & The number of items (key-value pairs) in map \textit{m}\\ \hline
\end{tabular}
\\

Maps are reference types that are cheap to pass no matter how much data they hold and Map lookups are fast.
\subsection{Creating Maps}
Maps are created using the syntaxes:
\begin{lstlisting}
make(map[KeyType]ValueType, initialCapacity)
make(map[KeyType]ValueType)
map[KeyType]ValueType{}
map[KeyType]ValueType{key1: value1, key2: value2, ..., keyN: valueN}
\end{lstlisting}
The built-in \textit{make()} function is used to create slices, maps, and channels. When used to create a map it creates an \textbf{empty map}, and if the optional \textit{initialCapacity} is specified, the map is initialized to have enough space for that number of items. If more items are added to the map than the \textbf{initial capacity} allows for, the map \textbf{will automatically grow} to accommodate the new items.\\
The last two syntaxes show how to create a map using the composite literal syntax; this is very convenient in practice, either to create a new empty map, or to create a map with some initial values. Examples:
\begin{lstlisting}
massForPlanet := make(map[string]float64) // Same as: map[string]float64{}
massForPlanet["Mercury"] = 0.06
massForPlanet["Venus"] = 0.82
massForPlanet["Earth"] = 1.00
massForPlanet["Mars"] = 0.11
fmt.Println(massForPlanet)
\end{lstlisting}
Result:
\begin{lstlisting}
map[Venus:0.82 Mars:0.11 Earth:1 Mercury:0.06]
\end{lstlisting}
For small maps it doesn't really matter whether we specify their initial capacity, but for large maps doing so can improve performance. In general \textbf{it is best to specify the initial capacity if it is known} (even if only approximately).\\
Maps use the \textit{[]} index operator just like arrays and slices, only for maps the index inside the square brackets is of the map's key type which might not be an \textit{int}\\
Remember pointers and struct can be used as map keys too.\\
When a \textbf{\textit{for ... range} loop is applied to a map} and there are two variables present, the loop returns a key and a value on each iteration until every key-value item has been returned or the loop is broken out of. If just one variable is present only the key is returned on each iteration. Since maps are unordered we cannot know what particular sequence the items will come in. Example:
\begin{lstlisting}
populationForCity := map[string]int{"Istanbul": 12610000,
"Karachi": 10620000, "Mumbai": 12690000, "Shanghai": 13680000}
//Note the for range loop with two variables
for city, population := range populationForCity {
	fmt.Printf("%-10s %8d\n", city, population)
}
\end{lstlisting}
\subsection{Map Lookups}
Go provides \textbf{two very similar syntaxes} for map lookups, both of which use the \textit{[]} index operator. Example of the simplest syntax:
\begin{lstlisting}
population := populationForCity["Mumbai"]
fmt.Println("Mumbai's population is", population)
population = populationForCity["Emerald City"]
fmt.Println("Emerald City's population is", population)
\end{lstlisting}
If we look up a key that is present in the map the corresponding value is returned. But if the key is not present then the map's value type's zero value is returned. So, in this example, we cannot tell whether the 0 returned for the "Emerald City" key means that the population of Emerald City really is zero, or that the city isn't in the map. Go's second map lookup syntax provides the solution to this problem.
\begin{lstlisting}
city := "Istanbul"
if population, found := populationForCity[city]; found {
fmt.Printf("%s's population is %d\n", city, population)
} else {
fmt.Printf("%s's population data is unavailable\n", city)
}
city = "Emerald City"
_, present := populationForCity[city]
fmt.Printf("%q is in the map == %t\n", city, present)
\end{lstlisting}
If we provide two variables for the map's \textit{[]} index operator to return to, the first will get the value that corresponds to the key (or the map's value type's zero value if the key isn't present), and the second will get true (or false if the key  isn't present). This allows us \textbf{to check for a key's existence in the map}.
\subsection{Modifying Maps}
Items, that is, key-value pairs, can be inserted into maps and deleted from maps. And any given key's value can be changed. Example:
\begin{lstlisting}
fmt.Println(len(populationForCity), populationForCity)
delete(populationForCity, "Shanghai") // Delete
fmt.Println(len(populationForCity), populationForCity)
populationForCity["Karachi"] = 11620000 // Update
fmt.Println(len(populationForCity), populationForCity)
populationForCity["Beijing"] = 11290000 // Insert
fmt.Println(len(populationForCity), populationForCity)
\end{lstlisting}
Result:
\begin{lstlisting}
4 map[Shanghai:13680000 Mumbai:12690000 Istanbul:12610000 Karachi:10620000]
3 map[Mumbai:12690000 Istanbul:12610000 Karachi:10620000]
3 map[Mumbai:12690000 Istanbul:12610000 Karachi:11620000]
4 map[Mumbai:12690000 Istanbul:12610000 Karachi:11620000 Beijing:11290000]
\end{lstlisting}
The syntax for inserting and updating map items is identical: If an item with the given key isn't present, a new item with the given key and value will be inserted; and if an item with the given key is present, its value will be set to the given value, and the original value will be discarded. And if we try to delete an item which isn't in the map, Go will safely do nothing.
\subsection{Key-Ordered Map Iteration and Map Inversion}
Here is an example that shows how to output the \textit{populationForCity} map in \textbf{alphabetical order}:
\begin{lstlisting}
cities := make([]string, 0, len(populationForCity))
for city := range populationForCity {
cities = append(cities, city)
}
sort.Strings(cities)
for _, city := range cities {
fmt.Printf("%-10s %8d\n", city, populationForCity[city])
}
\end{lstlisting}
Result:
\begin{lstlisting}
Beijing		11290000
Istanbul		12610000
Karachi		11620000
Mumbai		12690000
\end{lstlisting}
We begin by creating a slice of type \textit{[]string} with zero length (i.e., empty), but with enough capacity to hold all of the map's keys. Then we iterate over the map retrieving only the keys (since we have used just one variable, city , rather than the two needed to retrieve each key-value pair), and appending each city in turn to the cities slice. Next, we sort the slice, and then we iterate over the slice (ignoring the int index by using the blank identifier), looking up the corresponding city's population at each iteration.\\
We can easily \textbf{invert a map} whose values are unique and whose type is acceptable for use as map keys. Example:
\begin{lstlisting}
cityForPopulation := make(map[int]string, len(populationForCity))
for city, population := range populationForCity {
cityForPopulation[population] = city
}
fmt.Println(cityForPopulation)
\end{lstlisting}
Result:
\begin{lstlisting}
map[12610000:Istanbul 11290000:Beijing 12690000:Mumbai 11620000:Karachi]
\end{lstlisting}
\subsection{Other Examples with Maps}
Example of a map in Go:
\begin{lstlisting}
	var x map[string]int
\end{lstlisting}
The map type is represented by the keyword \textit{map} , followed by the key type in brackets and finally the value type. Like arrays and slices maps can be \textbf{accessed using brackets}.\\
\textbf{Maps have to be initialized before they can be used}.\\
We can also create maps with a \textbf{key type of \textit{int}} :
\begin{lstlisting}
	x := make(map[int]int)
	x[1] = 10
	fmt.Println(x[1])
\end{lstlisting}
This looks very much like an array but there are a few \textbf{differences}. First the \textbf{length} of a map (found by doing len(x) ) \textbf{can change} as we add new items to it. Second \textbf{maps are not sequential}.\\
We can also \textbf{delete items from a map} using the built-in \textit{delete} function:
	\begin{lstlisting}
delete(x, 1)
\end{lstlisting}
Accessing an element of a map can return \textbf{two values instead of just one}. \textbf{The first value is the result of the lookup, the second tells us whether or not the lookup was successful}.\\
This can be used to check if a key does not exist:
\begin{lstlisting}
	name, ok := elements["Un"]
	fmt.Println(name, ok)
\end{lstlisting}
If the key "Un" does not exist in the map \textit{name} is going to be an empty string and \textit{ok} is going to be \textit{false}.\\
Maps are also often used to store general information. For example instead of just storing the name of the element we store its standard
state (state at room temperature) as well:
\begin{lstlisting}
func main() {
	elements := map[string]map[string]string{
		"H": map[string]string{
			"name":"Hydrogen",
			"state":"gas",
		},
		"He": map[string]string{
			"name":"Helium",
			"state":"gas",
		},
		"Li": map[string]string{
			"name":"Lithium",
			"state":"solid",
		},
		"Be": map[string]string{
			"name":"Beryllium",
			"state":"solid",
		},
		"B": map[string]string{
			"name":"Boron",
			"state":"solid",
		},
		"C": map[string]string{
			"name":"Carbon",
			"state":"solid",
		},
		"N": map[string]string{
			"name":"Nitrogen",
			"state":"gas",
		},
		"O": map[string]string{
			"name":"Oxygen",
			"state":"gas",
		},
		"F": map[string]string{
			"name":"Fluorine",
			"state":"gas",
		},
		"Ne": map[string]string{
			"name":"Neon",
			"state":"gas",
		},
	}
	if el, ok := elements["Li"]; ok {
		fmt.Println(el["name"], el["state"])
	}
}
\end{lstlisting}
We now have a map of strings to maps of strings to strings.\\
Although maps are often used like this, there is a better way to store structured information.
\chapter{Functions}
\section{Basic Concepts}
A function is an independent section of code that maps zero or more \textbf{input parameters} to zero or more \textbf{output parameters}.\\
Functions start with the \textbf{keyword} \textit{func} , followed by the \textbf{function's name}. The parameters (inputs) of the function are defined like this: name type, name type, ... .\\
Collectively the parameters and the return type are known as the \textbf{function's signature}.\\
Finally we have the \textbf{function body} which is a series of statements between curly braces.\\
Example of a function:
\begin{lstlisting}
func average(xs []float64) float64 {
	total := 0.0
	for _, v := range xs {
		total += v
	}
	return total / float64(len(xs))
}
\end{lstlisting}
The \textit{return} statement causes the function to immediately stop and return the value after it to the function that called this one.\\
Some things to remember:
\begin{itemize}
\item Functions don't have access to anything in the calling function.
\item We can also name the return type
\begin{lstlisting}
func f2() (r int) {
	r = 1
	return
}
\end{lstlisting}
\end{itemize}
\section{Returning Multiple Values}
Go is also capable of \textbf{returning multiple values from a function}:
\begin{lstlisting}
func f() (int, int) {
	return 5, 6
}
func main() {
	x, y := f()
}
\end{lstlisting}
Three changes are necessary:
\begin{itemize}
\item change the return type to contain multiple types separated by , , 
\item change the expression after the return so that it contains multiple expressions separated by ,
\item and finally change the assignment statement so that multiple values are on the left side of the := or = .
\end{itemize}
Multiple values are often used to return an error value along with the result ( \textit{x, err := f()} ), or a boolean to indicate success ( \textit{x, ok := f()} ).
\section{Variadic Functions}
There is a special form available for the last parameter in a Go function:
\begin{lstlisting}
func add(args ...int) int {
	total := 0
	for _, v := range args {
		total += v
	}
	return total
}
func main() {
	fmt.Println(add(1,2,3))
}
\end{lstlisting}
By using \textit{...} before the type name of the last parameter you can indicate that \textbf{it takes zero or more of those parameters}. In this case we take zero or more \textit{int}s.\\
We can also \textbf{pass a slice} of int s by following the slice with \textit{...} :
\begin{lstlisting}
func main() {
	xs := []int{1,2,3}
	fmt.Println(add(xs...))
}
\end{lstlisting}
\section{Closure}
It is possible to create \textbf{functions inside of functions}:
\begin{lstlisting}
func main() {
	add := func(x, y int) int {
	return x + y
}
fmt.Println(add(1,1))
}
\end{lstlisting}
\textit{add} is a local variable that has the type \textit{func(int, int)} \textit{int} (a function that takes two int s and returns an int ).\\ 
\textbf{When you create a local function like this it also has access to other local variables}
\begin{lstlisting}
func main() {
	x := 0
	increment := func() int {
		x++
		return x
	}
	fmt.Println(increment())
	fmt.Println(increment())
}
\end{lstlisting}
\textit{increment} adds 1 to the variable \textit{x} which is defined in the main function's scope. This \textit{x} variable can be accessed and modified by the increment function. This is why the first time we call increment we see 1 displayed, but the second time we call it we see 2 displayed.\\
A function like this together with the non-local variables it references \textbf{is known as a closure}. In this case increment and the variable x form the closure.\\
Another example:
\begin{lstlisting}
func makeEvenGenerator() func() uint {
	i := uint(0)
	return func() (ret uint) {
		ret = i
		i += 2
		return
		}
}
func main() {
	nextEven := makeEvenGenerator()
	fmt.Println(nextEven()) // 0
	fmt.Println(nextEven()) // 2
	fmt.Println(nextEven()) // 4
}
\end{lstlisting}
\textit{makeEvenGenerator} returns a function which generates even numbers. Each time it's called it adds 2 to the local i variable which , unlike normal local variables, \textbf{persists between calls}.
\section{Recursion}
Finally a function is able to \textbf{call itself}.\\
Here is one way to compute the factorial of a number:
\begin{lstlisting}
func factorial(x uint) uint {
	if x == 0 {
	return 1
	}
	return x * factorial(x-1)
}
\end{lstlisting}
\section{Defer, Panic and Recover}
Go has a special statement called \textit{defer} which schedules a \textbf{function call to be run after the function completes}. Consider the following example:
\begin{lstlisting}
package main
import "fmt"
func first() {
	fmt.Println("1st")
}
func second() {
	fmt.Println("2nd")
}
func main() {
	defer second()
	first()
}
\end{lstlisting}
This program prints 1st followed by 2nd .\\
\textit{defer} is often used when resources need to be freed in some way.\\
We can \textbf{handle a run-time \textit{panic}} with the built-in \textit{recover} function. recover stops the \textit{panic} and returns the value that was passed to the call to \textit{panic} .\\
This is how to use it:
\begin{lstlisting}
package main
import "fmt"
func main() {
	defer func() {
	str := recover()
	fmt.Println(str)
	}()
	panic("PANIC")
}
\end{lstlisting}
\chapter{Pointers}
In this program the zero function will not modify the original \textit{x} variable in the main function.
\begin{lstlisting}
func zero(x int) {
	x = 0
}
func main() {
	x := 5
	zero(x)
	fmt.Println(x) // x is still 5
}
\end{lstlisting}
Pointers \textbf{reference a location in memory} where a value is stored rather than the value itself.
\begin{lstlisting}
func zero(xPtr *int) {
	*xPtr = 0
}
func main() {
	x := 5
	zero(&x)
	fmt.Println(x) // x is 0
}
\end{lstlisting}
\section{The * and the \& operators}
In Go a pointer is represented using the \textit{*} (asterisk) character followed by the type of the stored value. For example in the zero function \textit{xPtr} is a pointer to an \textit{int} .\\
\textit{*} is also used to \textbf{"dereference" pointer variables}. Dereferencing a pointer gives us access to the value the pointer points to (so \textit{*xPtr = 0}, means write 0 in the value pointed by xPtr).\\
If we try \textit{xPtr = 0} instead we will get a compiler error because \textit{xPtr} is not an \textit{int} it's a \textit{*int} , which can only be given another \textit{*int} .\\
Finally we use the \textit{\&} operator \textbf{to find the address of a variable}. \textit{\&x} returns a \textit{*int} (pointer to an int) because x is an int .

\section{More on Pointers}
A pointer is a \textbf{variable that holds another variable's memory address}. Pointers are created to point to variables of a particular type; this ensures that Go knows how large (i.e., how many bytes) the pointed-to value occupies.\\
Some things to remember about pointers:
\begin{itemize}
\item A variable pointed to by a pointer can be modified through the pointer.
\item Pointers are cheap to pass (8 bytes on 64-bit machines, 4 bytes on 32-bit machines), regardless of the size of the value they point to.
\item Pointed to variables persist in memory for as long as there is at least one pointer pointing to them, so their lifetime is independent of the scope in which they were created.
\end{itemize}
\subsection{\& Operator, the Address of Operator}
In Go the \& operator is overloaded. When used as a binary operator it performs a bitwise AND. When used as a unary operator \textbf{it returns the memory address of its operand}. The unary \& is sometimes called the address of operator.
\subsection{* Operator, the Contents of Operator}
The * operator is also overloaded. It multiplies its operands when used as a binary operator. And when used as a unary operator it \textbf{provides access to the value pointed to by the variable it is applied to}.\\
The unary * is sometimes called the \textbf{contents of} operator or the \textbf{indirection} operator or the \textbf{dereference} operator.\\
In addition to being the multiplication and dereferencing operator, the * operator is also overloaded for a third purpose: as a \textbf{type modifier}. When an * is placed on the left of a type name it changes the meaning of the name from specifying a value of the given type to specifying a pointer to a value of the given type.
\section{new}
Another way to get a pointer is to \textbf{use the built-in \textit{new} function}:
\begin{lstlisting}
func one(xPtr *int) {
	*xPtr = 1
}
func main() {
	xPtr := new(int)
	one(xPtr)
	fmt.Println(*xPtr) // x is 1
}
\end{lstlisting}
\textit{new} takes \textbf{a type as an argument}, allocates enough memory to fit a value of that type and \textbf{returns a pointer to it}.\\
Go is a \textbf{garbage collected programming language} which means memory is cleaned up automatically when nothing refers to it anymore.
\section{More about new()}
Go provides \textbf{two syntaxes} for creating variables and at the same time acquiring pointers to them:
\begin{itemize}
\item one using the built-in \textit{new()} function
\item the other using the \textit{address of operator}
\end{itemize}
Example:
\begin{lstlisting}
type composer struct {
	name string
	birthYear int
}
antonio := composer{"Antonio Teixeira", 1707} // composer value
agnes := new(composer) // pointer to composer
agnes.name, agnes.birthYear = "Agnes Zimmermann", 1845
julia := &composer{} // pointer to composer, alternative syntax
julia.name, julia.birthYear = "Julia Ward Howe", 1819
augusta := &composer{"Augusta Holmès", 1847} // pointer to composer
fmt.Println(antonio)
fmt.Println(agnes, augusta, julia)

{Antonio Teixeira 1707}
&{Agnes Zimmermann 1845} &{Augusta Holmès 1847} &{Julia Ward Howe 1819}
\end{lstlisting}
When Go prints pointers to struct \textit{s} it prints the dereferenced struct but prefixed with the \textit{\&} address of operator to indicate that it is a pointer.\\
Note the equivalence when the type is one that can be initialized using braces:\\
\begin{center}
\textit{new(Type)} is equivalent to  \textit{\&Type\{\}}
\end{center}
Both these syntaxes allocate a new zeroed value of the given \textit{Type} and return a pointer to the value. We don't have to worry about the value's lifetime or ever delete it, since Go's \textbf{memory management system takes care} of all that for us.
\section{Reference Types}
Go has reference types.\\
A variable of a reference type refers to a \textbf{hidden value in memory that stores the actual data}. Variables holding reference types are cheap to pass and are used with the same syntax as a value (i.e., we don't need to take a reference type's address or dereference it to access the value it refers to).\\
Once we reach the stage where we need to return more than four or five values from a function or method, it is best to pass a slice if the values are homogeneous, or to use a pointer to a struct if they are heterogeneous.\\
\textbf{Maps and slices are reference types}, and any changes made to a map or to a slice's items are visible to all the variables that refer to them. Example:
\begin{lstlisting}
func inflate(numbers []int, factor int) {
	for i := range numbers {
	numbers[i] *= factor
	}
}
//The function inflate changes the values of the slice passed as argument
grades := []int{87, 55, 43, 71, 60, 43, 32, 19, 63}
inflate(grades, 3)
fmt.Println(grades)

[261 165 129 213 180 129 96 57 189]
\end{lstlisting}
The grades slice is passed in as the parameter numbers, but unlike when we pass values, any changes applied to numbers are reflected in grades since they both refer to the same underlying slice.\\
Another example:
\begin{lstlisting}
type rectangle struct {
	x0, y0, x1, y1 int
	fill color.RGBA
}
func resizeRect(rect *rectangle, width, height int) {
	(*rect).x1 += width // Ugly explicit dereference
	rect.y1 += height // . automatically dereferences structs
}

rect := rectangle{4, 8, 20, 10, color.RGBA{0xFF, 0, 0, 0xFF}}
fmt.Println(rect)
resizeRect(&rect, 5, 5)
fmt.Println(rect)

{4 8 20 10 {255 0 0 255}}
{4 8 25 15 {255 0 0 255}}
\end{lstlisting}
In the \textit{resizeRect} function there are two ways to dereference a struct. In the second case relying on Go to do the dereferencing for us. This works because Go's . (dot) selector operator \textbf{automatically dereferences pointers to structs}.\\
Certain types in Go are reference types: maps, slices, channels, functions, and methods. Unlike with pointers, there is no special syntax for reference types since they are used just like values.\\
\section{Variables Holding Functions}
If we declare \textbf{a variable to hold a function}, the variable actually gets \textbf{a reference to the function}. Function references \textbf{know the signature} of the function they refer to, so it is not possible to pass a reference to a function that doesn't have the right signature

\chapter{Structs and Interfaces}
\section{Structs}
A struct is a type which contains named fields.\\
Example:
\begin{lstlisting}
type Circle struct {
	x float64
	y float64
	r float64
}
\end{lstlisting}
The \textit{type} keyword introduces a new type. It's followed by the name of the type ( \textit{Circle} ), the keyword \textit{struct} to indicate that we are defining a \textit{struct} type and a list of fields inside of curly braces. Like with functions we can collapse fields that have the same type:
\begin{lstlisting}
type Circle struct {
	x, y, r float64
}
\end{lstlisting}
\subsection{Initialization}
We can \textbf{create an instance} of our new Circle type in a variety of ways:
\begin{lstlisting}
var c Circle
\end{lstlisting}
Like with other data types, this will create a local \textit{Circle} variable that is by default set to zero. For a struct \textbf{zero means} each of the fields is set to their corresponding zero value ( 0 for \textit{int} s, 0.0 for \textit{float} s, "" for \textit{string} s, nil for pointers, ...).\\
We can also use the \textit{new} function:
\begin{lstlisting}
c:= new(Circle)
\end{lstlisting}
This allocates memory for all the fields, sets each of them to their zero value and returns a pointer.( *Circle )\\
More often we want to \textbf{give each of the fields a value}. We can do this in two ways. Like this:
\begin{lstlisting}
c := Circle{x: 0, y: 0, r: 5}
//or
c := Circle{0, 0, 5}
\end{lstlisting}
\subsection{Fields}
We can access fields using the \textit{.} operator:
\begin{lstlisting}
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5
\end{lstlisting}
One thing to remember is that \textbf{arguments are always copied in Go}. It means if a \textit{struct} is passed to a function the function will not modify the value of the fields of the \textit{struct} passed. If we want to do that, then we have to pass a pointer to the \textit{struct}.
\section{Methods}
Methods can be considered a \textbf{special type of function}. Example:
\begin{lstlisting}
func (c *Circle) area() float64 {
	return math.Pi * c.r*c.r
}
\end{lstlisting}
In between the keyword \textit{func} and the name of the function we've added a \textbf{"receiver"}. The receiver is like a parameter, it has a name and a type, but by creating the function in this way \textbf{it allows us to call the function using the \textit{.} operator}:
\begin{lstlisting}
fmt.Println(c.area())
\end{lstlisting}
\subsection{Embedded Types}
A struct's fields usually represent \textbf{the has-a relationship}. For example a Circle has a radius.\\
In other instances we may want to model a is-a relationship instead. Go supports the \textbf{is-a relationships by using an embedded types}. Example:
\begin{lstlisting}
type Person struct {
	Name string
}
func (p *Person) Talk() {
	fmt.Println("Hi, my name is", p.Name)
}
type Android struct {
	Person
	Model string
}
\end{lstlisting}
We use the type ( \textit{Person} ) and \textbf{don't give it a name}. When defined this way the \textit{Person} struct can be accessed using the type name:
\begin{lstlisting}
a := new(Android)
a.Person.Talk()
\end{lstlisting}
But we can also call any \textit{Person} methods directly on the \textit{Android} :
\begin{lstlisting}
a := new(Android)
a.Talk()
\end{lstlisting}
\section{Interfaces}
Interfaces are another type available in Go. For Example
\begin{lstlisting}
type Shape interface {
	area() float64
	}
\end{lstlisting}
Like a struct an interface is created using the \textit{type} keyword, followed by a name and the keyword \textit{interface} . But instead of defining fields, we define a \textbf{"method set"}. A method set is a list of methods that a type must have in order to \textbf{implement the interface}.\\
The interesting thing is we can use interface types as \textbf{arguments to
functions}:
\begin{lstlisting}
func totalArea(shapes ...Shape) float64 {
	var area float64
	for _, s := range shapes {
		area += s.area()
	}
	return area
}
\end{lstlisting}
We would call this function like this:
\begin{lstlisting}
fmt.Println(totalArea(&c, &r))
\end{lstlisting}
where \textit{c} and \textit{r} are two struct representing a circle and a rectangle.\\
Interfaces can also be used as \textbf{fields}:
\begin{lstlisting}
type MultiShape struct {
	shapes []Shape
}
\end{lstlisting}
\chapter{Concurrency}
Go has rich support for concurrency using \textbf{goroutines} and \textbf{channels}.
\section{Goroutines}
A \textbf{goroutine} is a function that is \textbf{capable of running concurrently with other functions}. To create a goroutine we use the keyword \textit{go} followed by a function invocation:
\begin{lstlisting}
package main
import "fmt"
func f(n int) {
	for i := 0; i < 10; i++ {
	fmt.Println(n, ":", i)
	}
}

func main() {
	go f(0)
	var input string
	fmt.Scanln(&input)
}
\end{lstlisting}
This program consists of two goroutines. The first goroutine is implicit and is the main function itself. The second goroutine is created when we call \textit{go f(0)} . Normally when we invoke a function our program will execute all the statements in a function and then return to the next line following the invocation. With a goroutine \textbf{we return immediately to the next line and don't wait for the function to complete}.\\
Goroutines are lightweight and we can easily create thousands of them. We can modify our program to run 10 goroutines by doing this:
\begin{lstlisting}
func main() {
	for i := 0; i < 10; i++ {
		go f(i)
	}
	var input string
	fmt.Scanln(&input)
}
\end{lstlisting}
\section{Channels}
Channels \textbf{provide a way for two goroutines to communicate with one another and synchronize their execution}. Example:
\begin{lstlisting}
package main
import (
	"fmt"
	"time"
)

func pinger(c chan string) {
	for i := 0; ; i++ {
		c <- "ping"
	}
}

func printer(c chan string) {
	for {
		msg := <- c
		fmt.Println(msg)
		time.Sleep(time.Second * 1)
	}
}

func main() {

var c chan string = make(chan string)
go pinger(c)
go printer(c)
var input string
fmt.Scanln(&input)
}
\end{lstlisting}
This program will print "ping" forever (hit enter to stop it). A \textbf{channel type} is represented with the keyword \textit{chan} followed by the type of the things that are passed on the channel (in this case we are passing strings). The \textit{<-} (left arrow) operator is used to \textbf{send and receive messages} on the channel. \textit{c <- "ping"} means send "ping" . \textit{msg := <- c} means receive a message and store it in \textit{msg} .\\
Using a channel like this \textbf{synchronizes the two goroutines}. When \textit{pinger} attempts to send a message on the channel it will wait until \textit{printer} is ready to receive the message. (this is known as blocking).
\subsection{Channel Direction}
We can \textbf{specify a direction on a channel type} thus restricting it to either sending or receiving. For example pinger's function signature can be changed to this:
\begin{lstlisting}
func pinger(c chan<- string)
\end{lstlisting}
Now c can only be sent to. Similarly we can change printer to this:
\begin{lstlisting}
func printer(c <-chan string)
\end{lstlisting}
\subsection{Select}
Go has a special statement called \textit{select} which works like a \textit{switch} but for channels:
\begin{lstlisting}
func main() {
	c1 := make(chan string)
	c2 := make(chan string)
	go func() {
		for {
			c1 <- "from 1"
			time.Sleep(time.Second * 2)
		}
	}()
	
	go func() {
		for {
			c2 <- "from 2"
			time.Sleep(time.Second * 3)
		}
	}()
	go func() {
		for {
			select {
				case msg1 := <- c1:
					fmt.	Println(msg1)
				case msg2 := <- c2:
					fmt.Println(msg2)
			}
		}
	}()

var input string
fmt.Scanln(&input)
}
\end{lstlisting}
This program prints "from 1" every 2 seconds and "from 2" every 3 seconds. \textit{select} \textbf{picks the first channel that is ready} and receives from it (or sends to it).\\
If more than one of the channels are ready then it randomly picks which one to receive from. If none of the channels are ready, the statement blocks until one becomes available.\\
The select statement is often used to \textbf{implement a timeout}:
\begin{lstlisting}
select {
case msg1 := <- c1:
	fmt.Println("Message 1", msg1)
case msg2 := <- c2:
	fmt.Println("Message 2", msg2)
case <- time.After(time.Second):
	fmt.Println("timeout")
}
\end{lstlisting}
\textit{time.After} creates a channel and after the given duration will send the current time on it.\\
We can also specify a \textit{default} case:
\begin{lstlisting}
select {
case msg1 := <- c1:
	fmt.Println("Message 1", msg1)
case msg2 := <- c2:
	fmt.Println("Message 2", msg2)
case <- time.After(time.Second):
	fmt.Println("timeout")
default:
	fmt.Println("nothing ready")
}
\end{lstlisting}
The \textit{default} case \textbf{happens immediately} if none of the channels are ready.
\chapter{Packages}
Go also provides another mechanism for code reuse: \textbf{packages}.
\section{Creating Packages}
Packages only really make sense in the context of a separate program which uses them.\\
See example in the book.\\
You may have noticed that every function in the packages we've seen start with a capital letter. In Go if something \textbf{starts with a capital letter} that means other packages (and programs) are able to see it. If we had named the function average instead of Average our main program would not have been able to see it.
\section{Documentation}
Go has the ability to automatically generate documentation for packages we write in a similar way to the standard package documentation. In a terminal run this command:
\begin{lstlisting}
godoc golang-book/chapter11/math Average
\end{lstlisting}
This documentation is also available in \textbf{web form} by running this command:
\begin{lstlisting}
godoc -http=":6060"
\end{lstlisting}
and entering this URL into your browser:
\begin{lstlisting}
http://localhost:6060/pkg/
\end{lstlisting}
\chapter{Testing}
Go includes a \textbf{special program }that makes writing tests easier. Example:
\begin{lstlisting}
package math
import "testing"
	func TestAverage(t *testing.T) {
		var v float64
		v = Average([]float64{1,2})
		if v != 1.5 {
		t.Error("Expected 1.5, got ", v)
	}
}
\end{lstlisting}
Now running this command
\begin{lstlisting}
go test
\end{lstlisting}
we get something like this:
\begin{lstlisting}
$ go test
PASS
ok golang-book/chapter11/math 0.032s
\end{lstlisting}
The \textit{go test} command will look for any tests in any of the files in the current folder and run them. Tests are identified by starting a function with the word \textit{Test} and taking one argument of type \textit{*testing.T} . In our case since we're testing the \textit{Average} function we name the test function \textit{TestAverage} .\\
Once we have the testing function setup we write tests that use the code we're testing.
\begin{lstlisting}
package math

import "testing"

type testpair struct {
	values []float64
	average float64
}

var tests = []testpair{
	{ []float64{1,2}, 1.5 },
	{ []float64{1,1,1,1,1,1}, 1 },
	{ []float64{-1,1}, 0 },
}

func TestAverage(t *testing.T) {
	for _, pair := range tests {
	v := Average(pair.values)
	if v != pair.average {
	t.Error(
		"For", pair.values,
		"expected", pair.average,
	"got", v,
	)
}
}
}
\end{lstlisting}
This is a \textbf{very common way} to setup tests; we create a struct to represent the inputs and outputs for the function. Then we create a list of these struct s (pairs). Then we loop through each one and run the function.
\chapter{Core Packages}
\section{Strings}
Go includes a large number of functions to work with strings in the \textit{strings} package:
\begin{lstlisting}
package main
import (
"fmt"
"strings"
)
func main() {
	fmt.Println(
	// true
	strings.Contains("test", "es"),
	// 2
	strings.Count("test", "t"),
	// true
	strings.HasPrefix("test", "te"),
	// true
	strings.HasSuffix("test", "st"),
	// 1
	strings.Index("test", "e"),
	// "a-b"
	strings.Join([]string{"a","b"}, "-"),
	// == "aaaaa"
	strings.Repeat("a", 5),
	// "bbaa"
	strings.Replace("aaaa", "a", "b", 2),
	// []string{"a","b","c","d","e"}
	strings.Split("a-b-c-d-e", "-"),
	// "test"
	strings.ToLower("TEST"),
	// "TEST"
	strings.ToUpper("test"),
	)
}
\end{lstlisting}
\section{Files and Folders}
To open a file in Go use the Open function from the \textit{os} package. Example, read a file:
\begin{lstlisting}
package main

import (
"fmt"
"io/ioutil"
)

func main() {
	bs, err := ioutil.ReadFile("test.txt")
		if err != nil {
		return
	}
	str := string(bs)
	fmt.Println(str)
}
\end{lstlisting}
Example, write a file:
\begin{lstlisting}
package main

import (
"os"
)

func main() {
	file, err := os.Create("test.txt")
	if err != nil {
		// handle the error here
	retu	rn
	}
	defer file.Close()
	file.WriteString("test")
}
\end{lstlisting}
Example, read a directory:
\begin{lstlisting}
package main

import (
"fmt"
"os"
)

func main() {
	dir, err := os.Open(".")
	if err != nil {
		return
	}
	defer dir.Close()
	fileInfos, err := dir.Readdir(-1)
	if err != nil {
		return
	}
	for _, fi := range fileInfos {
	fmt.Println(fi.Name())
	}
}
\end{lstlisting}
\section{Containers and Sort}
In addition to lists and maps Go has \textbf{several more collections} available underneath the container package. Lists are one example.
\subsection{List}
The \textit{container/list} package \textbf{implements a doubly-linked list}.\\
Each node of the list contains a \textbf{value} and a \textbf{pointer} to the next node. Since this is a doubly-linked list each node will also have pointers to the previous node. Example:
\begin{lstlisting}
package main

import ("fmt" ; "container/list")

func main() {
	var x list.List
	x.PushBack(1)
	x.PushBack(2)
	x.PushBack(3)
	for e := x.Front(); e != nil; e=e.Next() {
		fmt.Println(e.Value.(int))
	}
}
\end{lstlisting}
The zero value for a List is an empty list (a \textit{*List} can also be created using \textit{list.New} ). Values are appended to the list using \textit{PushBack} .
\subsection{Sort}
The sort package contains functions for sorting arbitrary data. There are several \textbf{predefined sorting functions} (for slices of \textit{ints} and \textit{floats}).
\chapter{Commentary}
Go provides C-style \textit{/* */} block comments and C++ style \textit{//} line comments. Line comments are the norm; block comments appear mostly as package comments, but are useful within an expression or to disable large swaths of code.\\
The program - and web server - \textit{godoc} processes Go source files to extract documentation about the contents of the package. Comments that appear before top-level declarations, with no intervening newlines, are extracted along with the declaration to serve as explanatory text for the item. The nature and style of these comments determines the quality of the documentation godoc produces. 
\end{document}
